#!/usr/bin/perl
## Pombert Lab, Illinois Tech, ACMdS, 2022

use strict;
use warnings;
use PerlIO::gzip;
use File::Basename;
use Getopt::Long qw(GetOptions);

my $name = 'subtel_table.pl';
my $version = '0.2';
my $update = '2022-08-30';

my $usage = <<"USAGE";

NAME                $name
VERSION             $version
UPDATE              $update
SYNOPSIS            Generates table with annotation information for proteins in the subtelomeres

EXAMPLE             ./${name} -f E_cuniculi_sub_proteins_no_hp_duf.tsv -af *.gesamt -a cunculi.annotations -rx *.gesamt \\
-b *.blastp.6

OPTIONS
-f (--file)         TSV generated by get_sub_proteins.pl
-af (--gesamt_AF)   Gesamt results for AlphaFold structures [Supports .gz files]
-rx (--gesamt_RX)   Gesamt results for RaptorX structures [Supports .gz files]
-tr (--gesamt_TR)   Gesamt results for trRosetta structures [Supports .gz files]
-a (--annotations)  Annotations files in TSV format
-b (--blast)        Blast results in tabular format generated by run_taxonomizedBLAST.pl
-o (--output)       Outputfile in TSV format [Default: out.tsv]

USAGE

die "$usage" unless @ARGV;

my @files;
my @gesamt_AF;
my @gesamt_RX;
my @gesamt_TR;
my @annotation;
my @blastp;
my $out = 'out.tsv';

GetOptions(
    'f|file=s{1,}' => \@files,
    'af|gesamt_AF=s{1,}' => \@gesamt_AF,
    'rx|gesamt_RX=s{1,}' => \@gesamt_RX,
    'tr|gesamt_TR=s{1,}' => \@gesamt_TR,
    'a|annotations=s{1,}' => \@annotation,
    'b|blast=s{1,}' => \@blastp,
    'o|output=s' => \$out
);

my @columns = (
    'Region',
    'Chromosome',
    'Locus_tag',
    'Start_pos',
    'End_pos',
    'Product',
    'Note',
    'AlphaFold',
    'RaptorX',
    'trRosetta',
#    'interB',
    'Annotations',
    'Blast'
);

# DUF-domain protein family database
# my %DUF_db = (
#     'DUF1609' => 'interAE',
#     'DUF866' => 'interB',
#     'DUF572' => 'interB',
#     'DUF5095' => 'interB',
#     'DUF5096' => 'interB',
#     'DUF5087' => 'interB',
#     'DUF5089' => 'interB',
#     'DUF5088' => 'interB',
#     'DUF5090' => 'interB',
#     'DUF5091' => 'interB',
#     'DUF5092' => 'interB',
#     'DUF5094' => 'interB',
#     'DUF5095' => 'interB',
#     'DUF5097' => 'interB',
#     'DUF5098' => 'interB',
#     'DUF5099' => 'interB',
#     'DUF5100' => 'interB',
#     'DUF5101' => 'interB',
#     'DUF3654' => 'interB',
#     'DUF3653' => 'interB',
#     'DUF2463' => 'interD',
#     'DUF1686' => 'interC',
#     'DUF1242' => 'interB'
# );

# Working on subtelomere protein file

my %data;
while (my $file = shift@files){
    
    open FI, "<", "$file";

    while (my $line = <FI>){
        chomp $line;

        if($line =~ /^#/){ next; }
        
        # Grabbing info from the subtel table
        else {
            my @columns = split("\t", $line);
            my $region = $columns[0];
            my $chrom = $columns[1];
            my $locus = $columns[2];
            my $Start_pos = $columns[3];
            my $End_pos = $columns[4];
            my $product = $columns[5];

            $data{$locus}{'Region'} = $region;
            $data{$locus}{'Chromosome'} = $chrom;
            $data{$locus}{'Locus_tag'} = $locus;
            $data{$locus}{'Start_pos'} = $Start_pos;
            $data{$locus}{'End_pos'} = $End_pos;
            $data{$locus}{'Product'} = $product;
        }
    }
}

## Working of AF gesamt files
while (my $af_file =shift@gesamt_AF){
    my ($af_name, $path) = fileparse($af_file);
    my ($locus) = $af_name =~ /^(\w+\d+_\d+g\d+)\S+/;

    # Accessing the locus tags already in %data
    for my $key (sort (keys %data)){

        # Checking if the GESAMT corresponds to the proteins in the list
        if ($locus eq $key){
            
            my $gzip = '';
            if ($af_file =~ /.gz$/) { $gzip = ':gzip'; }
            open AF, "<$gzip", "$af_file";

            while (my $line = <AF>){
                chomp $line;

                # Skipping header
                if($line =~ /^#/) { next; }
                
                # Grabbing relevant info
                elsif($line =~ /^\s+1\s+(\S+)\s+(\S+)\s+(\S+)/){
                    my $code = $1;
                    my $chain = $2;
                    my $qscore = $3;

                    # Populating db with AF info
                    $data{$locus}{'AlphaFold'}{'pdb'} = "${code}_${chain}";
                    $data{$locus}{'AlphaFold'}{'qscore'} = $qscore;
                }
            }
        }
    }
}


## Working on RaptorX gesamt files
while (my $rx_file = shift@gesamt_RX){
    my ($rx_name, $path) = fileparse($rx_file);
    my ($locus) = $rx_name =~ /^(\w+\d+_\d+g\d+)\S+/;

    # Accessing the locus tags already in %data
    for my $key (sort (keys %data)){
        
        # Checking if the GESAMT corresponds to the proteins in the list
        if ($locus eq $key){
            
            my $gzip = '';
            if ($rx_file =~ /.gz$/) { $gzip = ':gzip'; }
            
            open RX, "<$gzip", "$rx_file";

            while (my $line = <RX>){
                chomp $line;

                # Skipping header
                if($line =~ /^#/) { next; }

                # Grabbing relevant info
                elsif($line =~ /^\s+1\s+(\S+)\s+(\S+)\s+(\S+)/){
                    my $code = $1;
                    my $chain = $2;
                    my $qscore = $3;

                    # Populating db with RaptorX info
                    $data{$locus}{'RaptorX'}{'pdb'} = "${code}_${chain}";
                    $data{$locus}{'RaptorX'}{'qscore'} = $qscore;
                }
            }
        }
    }
}

## Working on RaptorX gesamt files
while (my $tr_file = shift@gesamt_TR){
    my ($tr_name, $path) = fileparse($tr_file);
    my ($locus) = $tr_name =~ /^(\w+\d+_\d+g\d+)\S+/;

    # Accessing the locus tags already in %data
    for my $key (sort (keys %data)){
        
        # Checking if the GESAMT corresponds to the proteins in the list
        if ($locus eq $key){
            
            my $gzip = '';
            if ($tr_file =~ /.gz$/) { $gzip = ':gzip'; }
            
            open RX, "<$gzip", "$tr_file";

            while (my $line = <RX>){
                chomp $line;

                # Skipping header
                if($line =~ /^#/) { next; }

                # Grabbing relevant info
                elsif($line =~ /^\s+1\s+(\S+)\s+(\S+)\s+(\S+)/){
                    my $code = $1;
                    my $chain = $2;
                    my $qscore = $3;

                    # Populating db with RaptorX info
                    $data{$locus}{'trRosetta'}{'pdb'} = "${code}_${chain}";
                    $data{$locus}{'trRosetta'}{'qscore'} = $qscore;
                }
            }
        }
    }
}

## Working on annotation file
while (my $ann_file = shift@annotation){
    
    open ANN, "<", "$ann_file";

    my $ref1 = undef();
    my $ref2 = undef();
    while (my $line = <ANN>){
        chomp $line;

        # Skipping header
        if ($line =~ /^#/){ 
            my @columns = split("\t", $line);
            $ref1 = $columns[14];
            if (exists $columns[16]){
                $ref2 = $columns[16];
            }
        }
        else{
            my @columns = split("\t", $line);
            my $locus = $columns[0];
            my $SP_eval = $columns[1];
            my $SP_ann = $columns[2];
            my $TR_eval = $columns[3];
            my $TR_ann = $columns[4];
            my $PFAM_eval = $columns[5];
            my $PFAM_ann = $columns[6];
            my $TIGR_eval = $columns[7];
            my $TIGR_ann = $columns[8];
            my $HAMAP_score = $columns[9];
            my $HAMAP_ann = $columns[10];
            my $CDD_eval = $columns[11];
            my $CDD_ann = $columns[12];
            my $ref1_eval = $columns[13];
            my $ref1_ann = $columns[14];
            my $ref2_eval = undef();
            my $ref2_ann = undef();
            if (exists $columns[15]){
                $ref2_eval = $columns[15];
                $ref2_ann = $columns[16];
            }

            for my $key (sort (keys %data)){
            
                # Working only of the proteins that are in the subtel list
                if ($locus eq $key){

                    # Filtering the sequence homology annotation results by e-value
                    if ($SP_eval ne 'NA' && $SP_eval <= 1e-10){
                        $data{$locus}{'Annotations'}{'SP'} = 'SwissProt';
                        $data{$locus}{'Products'}{'SP'} = $SP_ann;
                    }
                    if ($TR_eval ne 'NA' && $TR_eval <= 1e-10){
                        $data{$locus}{'Annotations'}{'TR'} = 'TrEMBL';
                        $data{$locus}{'Products'}{'TR'} = $TR_ann;
                    }
                    if ($PFAM_eval ne 'NA' && $PFAM_eval <= 1e-10){
                        $data{$locus}{'Annotations'}{'PFAM'} = 'PFAM';
                        $data{$locus}{'Products'}{'PFAM'} = $PFAM_ann;
                    }
                    if ($TIGR_eval ne 'NA' && $TIGR_eval <= 1e-10){
                        $data{$locus}{'Annotations'}{'TIGR'} = 'TIGR';
                        $data{$locus}{'Products'}{'TIGR'} = $TIGR_ann;
                    }
                    if ($HAMAP_score ne 'NA'){
                        $data{$locus}{'Annotations'}{'HAMAP'} = 'HAMAP';
                        $data{$locus}{'Products'}{'HAMAP'} = $HAMAP_ann;
                    }
                    if ($CDD_eval ne 'NA' && $CDD_eval <= 1e-10){
                        $data{$locus}{'Annotations'}{'CDD'} = 'CDD';
                        $data{$locus}{'Products'}{'CDD'} = $CDD_ann;
                    }
                    if ($ref1_eval ne 'NA' && $ref1_eval <= 1e-10){
                        $data{$locus}{'Annotations'}{'Ref1'} = $ref1;
                        $data{$locus}{'Products'}{'Ref1'} = $ref1_ann;
                    }
                    if (defined $ref2_eval){
                        if ($ref2_eval ne 'NA' && $ref2_eval <= 1e-10){
                            $data{$locus}{'Annotations'}{'Ref2'} = $ref2;
                            $data{$locus}{'Products'}{'Ref2'} = $ref2_ann;
                        }
                    }
                    # Checking if we have 3D structural homology to print later under annotations
                    if (exists $data{$locus}{'AlphaFold'}){
                        if ( $data{$locus}{'AlphaFold'}{'qscore'} >= 0.3 ){
                            $data{$locus}{'Annotations'}{'3D'} = '3D homology';
                        }
                    }
                    if (exists $data{$locus}{'RaptorX'}){
                        if ( $data{$locus}{'RaptorX'}{'qscore'} >= 0.3) {
                            $data{$locus}{'Annotations'}{'3D'} = '3D homology';
                        }
                    }
                    if (exists $data{$locus}{'trRosetta'}){
                        if ( $data{$locus}{'trRosetta'}{'qscore'} >= 0.3) {
                            $data{$locus}{'Annotations'}{'3D'} = '3D homology';
                        }
                    }
                }
            }
        }
    }
}

# Woking on Blastp files from the run_taxnomizideBlast.pl
while (my $blast = shift@blastp){
    my ($blast_name, $path) = fileparse($blast);
    my ($locus) = $blast_name =~ /(.*)?\.fasta/;

    # Accessing the locus tags already in %data
    for my $key (sort (keys %data)){

        # Checking if the GESAMT corresponds to the proteins in the list
        if ($locus eq $key){
            
            my %unique_microsp;
            my %unique_other;
            my @hits_microsp;
            my @hits_other;

            open BLA, "<", "$blast";
            
            while (my $line = <BLA>){
                chomp $line;

                my @columns = split("\t", $line);
                my $eval = $columns[7];
                my ($species) = $columns[-3] =~ /(\w+\s+\w+)/;
                my $group = $columns[-1];

                # For microsporidians, keep species names
                if ($group eq 'microsporidians'){
                    push (@hits_microsp, $species); 
                }
                # For others, filter by evalue and use group name
                else{
                    if ($eval <= 1e-10){
                        push(@hits_other, $group);
                    }
                }
                # Removing duplicates from the array
                foreach(@hits_microsp){
                    if (exists $unique_microsp{$_}){
                        next;
                    }
                    else {
                        $unique_microsp{$_} = '';
                    }
                }
                foreach(@hits_other){
                    if (exists $unique_other{$_}){
                        next;
                    }
                    else {
                        $unique_other{$_} = '';
                    }
                }
            }
            for (sort(keys %unique_microsp)){
                push ( @{$data{$locus}{'Blast'}{'microsp'}}, "$_") ;
            }
            for (sort(keys %unique_other)){
                push ( @{$data{$locus}{'Blast'}{'other'}}, "$_") ;
            }
        }
    }
}
open OUT, ">", "$out";

# Printing header
foreach(@columns){ print OUT "$_\t"; }
print OUT "\n";

# Printing content
for my $acc (sort (keys %data)){

    # Printing out columns
    for (0..5){ print OUT "$data{$acc}{$columns[$_]}\t"; }
    print OUT "\t"; ## Empty colum for NOTES
    
    # Printing out AF gesamt
    if (defined $data{$acc}{'AlphaFold'}{'pdb'} && defined $data{$acc}{'AlphaFold'}{'qscore'}){
        print OUT "$data{$acc}{'AlphaFold'}{'pdb'};$data{$acc}{'AlphaFold'}{'qscore'};\t";
    }
    else { print OUT "--\t";
    }

    # Printing out RAPTORX gesamt
    if (defined $data{$acc}{'RaptorX'}{'pdb'} && defined $data{$acc}{'RaptorX'}{'qscore'}){
        print OUT "$data{$acc}{'RaptorX'}{'pdb'};$data{$acc}{'RaptorX'}{'qscore'};\t";
    }
    else { print OUT "--\t";
    }
    
    # Printing trRosetta gesamt
    if (defined $data{$acc}{'trRosetta'}{'pdb'} && defined $data{$acc}{'trRosetta'}{'qscore'}){
        print OUT "$data{$acc}{'trRosetta'}{'pdb'};$data{$acc}{'trRosetta'}{'qscore'};\t";
    }
    else { print OUT "--\t";
    }

    # # Printing out DUF-domain protein families
    # if (exists $data{$acc}{'Product'}){
    #     my $ann = $data{$acc}{'Product'};

    #     if ($ann =~ /^(DUF\d+)\s+/){
    #         my $duf_ann = $1;

    #         if (exists $DUF_db{$duf_ann}){
    #             my $fam = $DUF_db{$duf_ann};
    #             print OUT "$fam";
    #         }
    #         # Just in case a DUF domain is not in the DB
    #         else{
    #             print OUT "$duf_ann";
    #         }
    #     }
    #     else{
    #         print OUT 'Other';
    #     }
    # }
    # print OUT "\t";


    # Printing out annotation tools with hits
    my @sorted_annots = sort(keys %{ $data{$acc}{'Annotations'} });

    if (scalar(@sorted_annots) >= 1){
        for (0..$#sorted_annots) {   
            my $an_key = $sorted_annots[$_];
            print OUT "$data{$acc}{'Annotations'}{$an_key};";
        }
    }
    else {print OUT '--'; }
    print OUT "\t";

    # Printing out blast result
    if (exists $data{$acc}{'Blast'}{'microsp'} ){
        print OUT 'Microsporidians: ';
        foreach(@{$data{$acc}{'Blast'}{'microsp'}}){
            print OUT "$_;";
        }
    }
    if (exists $data{$acc}{'Blast'}{'other'} ){
        print OUT 'Other: ';
        foreach(@{$data{$acc}{'Blast'}{'other'}}){
            print OUT "$_;";
        }
    }
    unless ($data{$acc}{'Blast'}{'microsp'} || $data{$acc}{'Blast'}{'other'}) {
        print OUT '--';
    }
    print OUT "\n";
}
