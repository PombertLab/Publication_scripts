#!/usr/bin/perl
my $name = 'parse_pfam_search.pl';
my $version = '0.1';
my $updated = '2022-10-25';

use strict;
use warnings;
use Getopt::Long qw(GetOptions);

my $usage = << "USAGE";
NAME		${name}
VERSION		${version}
UPDATED		${updated}
SYNOPSIS	Parses the content of Pfam searches performed with hmmsearch by
		regular expression(s) matching specified terms

REQS		Pfam-A.hmm.dat
		- http://ftp.ebi.ac.uk/pub/databases/Pfam/current_release/Pfam-A.hmm.dat.gz

COMMAND		${name} \
		  -d Pfam-A.hmm.dat \
		  -h *.tbl \
		  -r methyl mbd \
		  -e 1e-05

OPTIONS:
-d (--dat)	Pfam-A.hmm.dat file from Pfam
-h (--hits)	Tab-delimited .tbl files generated by hmmsearch (from hmmer)
-r (--reg)	Regular expression(s) to search for
-e (--eval)	E-value cutoff [Default: 1e-01]
USAGE
die "\n$usage\n" unless @ARGV;

my $dat;
my @hits;
my @regs;
my $ev_cutoff = 1e-01;
GetOptions(
	'd|dat=s' => \$dat,
	'h|hits=s@{1,}' => \@hits,
	'r|reg=s@{1,}' => \@regs,
	'e|eval=s' => \$ev_cutoff
);

########## Creating database of Pfam IDs and their descriptions ################

open DAT, "<", $dat or die "Can't open $dat: $!\n";

my %dat_ids;
my $accession_id;
my $desc;
while (my $line = <DAT>){

	chomp $line;

	if ($line =~ /^#=GF AC   (.*)$/){
		$accession_id = $1;
	}
	elsif ($line =~ /^#=GF DE   (.*)$/){
		$desc = $1;
		$dat_ids{$accession_id} = $desc;
	}

}

########## Parsing hmmer output files ######################################

while (my $hit_file = shift@hits){

	open HIT, "<", $hit_file or die "Can't open $hit_file: $!\n";
	my ($prefix) = $hit_file =~ /^(.*)\.\w+$/;
	my $outfile = $prefix.'.parsed.tsv';
	open OUT, ">", $outfile or die "Can't create $outfile: $!\n";

	my %matches;

	while (my $line = <HIT>){
		chomp $line;
		if ($line =~ /^#/){
			next;
		}
		else {
			# target_name        accession  query_name           accession    E-value  score  bias   E-value  score  bias   exp reg clu  ov env dom rep inc description_of_target
			my @data = split(/\s+/, $line);
			my $target = $data[0];
			my $accession = $data[3];
			my $eval = $data[4];

			my $description = $dat_ids{$accession};
			if ($eval <= $ev_cutoff){
				foreach my $regex (@regs){
					if ( ($description =~ /$regex/i) or ($accession =~ /$regex/i) ){
						my $match = $line."\t".$description;
						push (@{$matches{$target}}, $match);
						last;
					}
				}
			}

		}
	}

	foreach my $key (sort (keys %matches)){
		my @array = @{$matches{$key}};
		foreach (@array){
			print OUT "$_\n";
		}
	}

}